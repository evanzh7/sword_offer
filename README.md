|序号|题目|知识点|
|---|---|---|---|
|1|赋值运算符函数|编程语言|
|2|[实现Singleton模式](#2)|编程语言|
|3|数组中的重复数字|数组|
|4|二维数组中的查找|数组|
|5|替换空格|字符串|
|6|从尾到头打印链表|链表|
|7|重建二叉树|树|
|8|二叉树的下一个节点|树|
|9|用两个栈实现队列|栈和队列|
|10|斐波那契额数列|递归和循环|
|11|旋转数组的最小数字|查找和排序|
|12|矩阵中的路径|回溯法|
|13|机器人的运动范围|回溯法|
|14|剪绳子|动态规划与贪婪算法|
|15|二进制中1的个数|位运算|
|16|数值的整数资方|代码的完整性|
|17|打印从1到最大的n位数|代码的完整性|
|18|删除链表的节点|代码的完整性|
|19|正则表达式匹配|代码的完整性|
|20|表示数值的字符串|代码的完整性|
|21|调整数组顺序使奇数位于偶数前面|代码的完整性|
|22|链表中倒数第k个节点|代码的鲁棒性|
|23|链表中环的入口节点|代码的鲁棒性|
|24|反转链表|代码的鲁棒性|
|25|合并两个排序的链表|代码的鲁棒性|
|26|树的子结构|代码的鲁棒性|
|27|二叉树的镜像|画图让抽象问题形象化|
|28|对称的二叉树|画图让抽象问题形象化|
|29|顺时针打印矩阵|画图让抽象问题形象化|
|30|包含min函数的栈|举例让抽象问题具体化|
|31|栈的压入、弹出序列|举例让抽象问题具体化|
|32|从上到下打印二叉树|举例让抽象问题具体化|
|33|二叉搜索树的后序遍历序列|举例让抽象问题具体化|
|34|二叉树中和为某一值的路径|举例让抽象问题具体化|
|35|复杂链表的复制|分解让复杂问题简单化|
|36|二叉搜索树与双向链表|分解让复杂问题简单化|
|37|序列化二叉树|分解让复杂问题简单化|
|38|字符串的排列|分解让复杂问题简单化|
|39|数组中出现次数超过一半的数字|时间效率|
|40|最小的k个数|时间效率|
|41|数据流中的中位数|时间效率|
|42|连续子数组的最大和|时间效率|
|43|1~n整数中1出现的次数|时间效率|
|44|数字序列中某一位的数字|时间效率|
|45|把数组排成最小的数|时间效率|
|46|把数字翻译成字符串|时间效率|
|47|礼物的最大价值|时间效率|
|48|最长不含重复字符串的子字符串|时间效率|
|49|丑数|时间效率与空间效率的平衡|
|50|第一个只出现一次的数字|时间效率与空间效率的平衡|
|51|数组中的逆序对|时间效率与空间效率的平衡|
|52|两个链表的第一个公共节点|时间效率与空间效率的平衡|
|53|在排序数组中查找数字|知识迁移能力|
|54|二叉搜索树的第k大节点|知识迁移能力|
|55|二叉树的深度|知识迁移能力|
|56|数组中熟数字出现的次数|知识迁移能力|
|57|和为s的数字|知识迁移能力|
|58|翻转字符串|知识迁移能力|
|59|队列的最大值|知识迁移能力|
|60|n个骰子的点数|抽象建模能力|
|61|扑克牌中的顺子|抽象建模能力|
|62|圆圈中最后剩下的数字|抽象建模能力|
|63|股票的最大利润|抽象建模能力|
|64|求1+2+...+n|发散思维能力|
|65|不用加减乘除做加法|发散思维能力|
|66|构建乘积数组|发散思维能力|

<h3 id="2">3. 实现Singleton模式</h3>
